package Chap4_스택과큐;

public class 링버퍼 {
 private Point[] data;            // 큐용 배열
 private int capacity;         // 큐의 크기
 private int front;            // 맨 처음 요소 커서
 private int rear;             // 맨 끝 요소 커서
 private int num;

 //--- 실행시 예외: 큐가 비어있음 ---//
 public class Empty링버퍼Exception extends RuntimeException {
     public Empty링버퍼Exception() { }
 }

 //--- 실행시 예외: 큐가 가득 찼음 ---//
 public class Overflow링버퍼Exception extends RuntimeException {
     public Overflow링버퍼Exception() { }
 }

 //--- 생성자(constructor) ---//
 public 링버퍼(int maxlen) {
     front = rear = 0;
     capacity = maxlen;
     try {
         data = new Point[capacity];          // 큐 본체용 배열을 생성
     } catch (OutOfMemoryError e) {        // 생성할 수 없음
         capacity = 0;
     }
 }
 
 //--- 큐에 데이터를 인큐 ---//
 public Point push(Point x) throws Overflow링버퍼Exception {
     if (num >= capacity)
         throw new Overflow링버퍼Exception();            // 큐가 가득 찼음
     data[rear++] = x;
     num++;
     if (rear == capacity)
         rear = 0;
     return x;
 }

 //--- 큐에서 데이터를 디큐 ---//
 public Point pop() throws Empty링버퍼Exception {
     if (num <= 0)
         throw new Empty링버퍼Exception();            // 큐가 비어있음
     Point x = data[front++];
     num--;
     if (front == capacity)
         front = 0;
     return x;
 }

 //--- 큐에서 데이터를 피크(프런트 데이터를 들여다봄) ---//
 public Point peek() throws Empty링버퍼Exception {
     if (num <= 0)
         throw new Empty링버퍼Exception();            // 큐가 비어있음
     return data[front];
 }

 //--- 큐가 비어있는가? ---//
 public boolean isEmpty() {
     return num <= 0;
 }

 //--- 큐가 가득 찼는가? ---//
 public boolean isFull() {
     return num >= capacity;
 }

 //--- 큐 안의 모든 데이터를 프런트 → 리어 순으로 출력 ---//
 public void dump() {
     if (num <= 0)
         System.out.println("큐가 비어있습니다.");
     else {
         for (int i = 0; i < num; i++)
             System.out.print(data[(i + front) % capacity] + " ");
         System.out.println();
     }
 }
}