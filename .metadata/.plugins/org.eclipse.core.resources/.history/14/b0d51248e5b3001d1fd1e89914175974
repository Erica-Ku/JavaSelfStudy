package Chap5_재귀알고리즘;

import java.util.*;

public class Maze_1 {

    static class Offset {
        int a, b;
        Offset(int a, int b) {
            this.a = a;
            this.b = b;
        }
    }

    static class Item {
        int x;
        int y;
        int dir;
        Item(int x, int y, int dir) {
            this.x = x;
            this.y = y;
            this.dir = dir;
        }
    }

    static void initializeMoveOffsets(Offset[] move) {
        move[0] = new Offset(-1, 0);
        move[1] = new Offset(-1, 1);
        move[2] = new Offset(0, 1);
        move[3] = new Offset(1, 1);
        move[4] = new Offset(1, 0);
        move[5] = new Offset(1, -1);
        move[6] = new Offset(0, -1);
        move[7] = new Offset(-1, -1);
    }

    static void findPath(int[][] maze, int[][] visited, int x, int y) {
        //List<Item> stack = new ArrayList<>();
        MazeStack st = new MazeStack(100);
        Offset[] move = new Offset[8];
        initializeMoveOffsets(move);

        visited[x][y] = 1;
        Item current = new Item(x, y, 2);
        st.push(current);

        // Search for the exit using a depth-first search algorithm.
        while (!stack.isEmpty()) {
            current = stack.remove(stack.size() - 1);
            int i = current.x;
            int j = current.y;
            int d = current.dir;

            while (d < 8) {
                // Calculate the next position to move to.
                int g = i + move[d].a;
                int h = j + move[d].b;

                if (g == 12 && h == 15) {
                    // We found the exit, mark it as visited and print the solution.
                    visited[g][h] = 2;
                    System.out.println("Solution found: (" + i + ", " + j + ") -> (12, 15)");
                    System.out.println();
                    return;
                }

                if (maze[g][h] == 0 && visited[g][h] == 0) {
                    // The next position is valid and unvisited, mark it as visited and push it onto the stack.
                    visited[g][h] = 1;
                    Item next = new Item(g, h, 2);
                    stack.add(next);
                    i = g;
                    j = h;
                    d = 0;
                } else {
                    // The next position is either invalid or has already been visited, try the next direction.
                    if (d + 1 >= 8) {
                        // We've tried all possible directions, mark the current position as visited and backtrack.
                        visited[i][j] = 1;
                        break;
                    }
                    visited[i][j] = 2;
                }
                d++;
            }
        }